import { InlineShortcutDefinition, getInlineShortcut } from './shortcuts';

/**
 * Attempts to parse and interpret a string in an unknown format, possibly
 * ASCIIMath and return a canonical LaTeX string.
 *
 * The format recognized are one of these variations:
 * - ASCIIMath: Only supports a subset
 * (1/2x)
 * 1/2sin x                     -> \frac {1}{2}\sin x
 * 1/2sinx                      -> \frac {1}{2}\sin x
 * (1/2sin x (x^(2+1))          // Unbalanced parentheses
 * (1/2sin(x^(2+1))             -> \left(\frac {1}{2}\sin \left(x^{2+1}\right)\right)
 * alpha + (pi)/(4)             -> \alpha +\frac {\pi }{4}
 * x=(-b +- sqrt(b^2 – 4ac))/(2a)
 * alpha/beta
 * sqrt2 + sqrtx + sqrt(1+a) + sqrt(1/2)
 * f(x) = x^2 "when" x >= 0
 * AA n in QQ
 * AA x in RR "," |x| > 0
 * AA x in RR "," abs(x) > 0
 *
 * - UnicodeMath (generated by Microsoft Word): also only supports a subset
 *      - See https://www.unicode.org/notes/tn28/UTN28-PlainTextMath-v3.1.pdf
 * √(3&x+1)
 * {a+b/c}
 * [a+b/c]
 * _a^b x
 * lim_(n->\infty) n
 * \iint_(a=0)^\infty  a
 *
 * - "JavaScript Latex": a variant that is LaTeX, but with escaped backslashes
 *  \\frac{1}{2} \\sin x
 */
export function parseMathString(
    s: string,
    options?: {
        format?: string;
        inlineShortcuts?: { [key: string]: InlineShortcutDefinition };
    }
): [string, string] {
    if (!s) return ['latex', ''];

    // Nothing to do if a single character
    if (s.length <= 1) return ['latex', s];

    if (!options || options.format !== 'ASCIIMath') {
        // This is not explicitly ASCIIMath. Try to infer if this is LaTex...

        // If the strings is surrounded by `$..$` or `$$..$$`, assumes it is LaTeX
        const trimedString = s.trim();
        if (
            (trimedString.startsWith('$$') && trimedString.endsWith('$$')) ||
            (trimedString.startsWith('\\[') && trimedString.endsWith('\\]')) ||
            (trimedString.startsWith('\\(') && trimedString.endsWith('\\)'))
        ) {
            return [
                'latex',
                trimedString.substring(2, trimedString.length - 2),
            ];
        }

        if (trimedString.startsWith('$') && trimedString.endsWith('$')) {
            return [
                'latex',
                trimedString.substring(1, trimedString.length - 1),
            ];
        }

        // Replace double-backslash (coming from JavaScript) to a single one
        s = s.replace(/\\\\([^\s\n])/g, '\\$1');

        if (/\\/.test(s)) {
            // If the string includes a '\' it's probably a LaTeX string
            // (that's not completely true, it could be a UnicodeMath string, since
            // UnicodeMath supports some LaTeX commands. However, we need to pick
            // one in order to correctly interpret {} (which are argument delimiters
            // in LaTeX, and are fences in UnicodeMath)
            return ['latex', s];
        }
    }

    s = s.replace(/\u2061/gu, ''); // Remove function application
    s = s.replace(/\u3016/gu, '{'); // WHITE LENTICULAR BRACKET (grouping)
    s = s.replace(/\u3017/gu, '}'); // WHITE LENTICULAR BRACKET (grouping)

    s = s.replace(/([^\\])sinx/g, '$1\\sin x'); // common typo
    s = s.replace(/([^\\])cosx/g, '$1\\cos x '); // common typo
    s = s.replace(/\u2013/g, '-'); // EN-DASH, sometimes used as a minus sign

    return [
        options?.format || 'ASCIIMath',
        parseMathExpression(s, options ?? {}),
    ];
}

function parseMathExpression(
    s: string,
    options: {
        format?: string;
        inlineShortcuts?: { [key: string]: InlineShortcutDefinition };
    }
): string {
    if (!s) return '';
    let done = false;
    let m;

    if (!done && (s[0] === '^' || s[0] === '_')) {
        // Superscript and subscript
        m = parseMathArgument(s.substr(1), {
            inlineShortcuts: options?.inlineShortcuts ?? {},
            noWrap: true,
        });
        s = s[0] + '{' + m.match + '}';
        s += parseMathExpression(m.rest, options);
        done = true;
    }

    if (!done) {
        m = s.match(/^(sqrt|\u221a)(.*)/);
        if (m) {
            // Square root
            m = parseMathArgument(m[2], {
                inlineShortcuts: options?.inlineShortcuts ?? {},
                noWrap: true,
            });
            const sqrtArgument = m.match || '\\placeholder{}';
            s = '\\sqrt{' + sqrtArgument + '}';
            s += parseMathExpression(m.rest, options);
            done = true;
        }
    }

    if (!done) {
        m = s.match(/^(\\cbrt|\u221b)(.*)/);
        if (m) {
            // Cube root
            m = parseMathArgument(m[2], {
                inlineShortcuts: options?.inlineShortcuts ?? {},
                noWrap: true,
            });
            const sqrtArgument = m.match || '\\placeholder{}';
            s = '\\sqrt[3]{' + sqrtArgument + '}';
            s += parseMathExpression(m.rest, options);
            done = true;
        }
    }

    if (!done) {
        m = s.match(/^abs(.*)/);
        if (m) {
            // Absolute value
            m = parseMathArgument(m[1], {
                inlineShortcuts: options?.inlineShortcuts ?? {},
                noWrap: true,
            });
            s = '\\left|' + m.match + '\\right|';
            s += parseMathExpression(m.rest, options);
            done = true;
        }
    }

    if (!done) {
        m = s.match(/^["”“](.*?)["”“](.*)/);
        if (m) {
            // Quoted text
            s = '\\text{' + m[1] + '}';
            s += parseMathExpression(m[2], options);
            done = true;
        }
    }

    if (!done) {
        m = s.match(/^([^a-zA-Z({[_^\\\s"]+)(.*)/);
        // A string of symbols...
        // Could be a binary or relational operator, etc...
        if (m) {
            s = paddedShortcut(m[1], options);
            s += parseMathExpression(m[2], options);
            done = true;
        }
    }

    if (!done && /^(f|g|h)[^a-zA-Z]/.test(s)) {
        // This could be a function...
        m = parseMathArgument(s.substring(1), {
            inlineShortcuts: options.inlineShortcuts ?? {},
            noWrap: true,
        });
        if (s[1] === '(') {
            s = s[0] + '\\mleft(' + m.match + '\\mright)';
        } else {
            s = s[0] + m.match;
        }
        s += parseMathExpression(m.rest, options);
        done = true;
    }

    if (!done) {
        m = s.match(/^([a-zA-Z]+)(.*)/);
        if (m) {
            // Some alphabetical string...
            // Could be a function name (sin) or symbol name (alpha)
            s = paddedShortcut(m[1], options);
            s += parseMathExpression(m[2], options);
            done = true;
        }
    }

    if (!done) {
        m = parseMathArgument(s, {
            inlineShortcuts: options.inlineShortcuts ?? {},
            noWrap: true,
        });
        if (m.match && m.rest[0] === '/') {
            // Fraction
            const m2 = parseMathArgument(m.rest.substr(1), {
                inlineShortcuts: options.inlineShortcuts ?? {},
                noWrap: true,
            });
            if (m2.match) {
                s =
                    '\\frac{' +
                    m.match +
                    '}{' +
                    m2.match +
                    '}' +
                    parseMathExpression(m2.rest, options);
            }
            done = true;
        } else if (m.match) {
            if (s[0] === '(') {
                s =
                    '\\left(' +
                    m.match +
                    '\\right)' +
                    parseMathExpression(m.rest, options);
            } else {
                s = m.match + parseMathExpression(m.rest, options);
            }
            done = true;
        }
    }

    if (!done) {
        m = s.match(/^(\s+)(.*)$/);
        // Whitespace
        if (m) {
            s = ' ' + parseMathExpression(m[2], options);
            done = true;
        }
    }

    return s;
}

/**
 * Parse a math argument, as defined by ASCIIMath and UnicodeMath:
 * - Either an expression fenced in (), {} or []
 * - a number (- sign, digits, decimal point, digits)
 * - a single [a-zA-Z] letter (an identifier)
 * - a multi-letter shortcut (e.g., pi)
 * - a LaTeX command (\pi) (for UnicodeMath)
 * @return
 * - match: the parsed (and converted) portion of the string that is an argument
 * - rest: the raw, unconverted, rest of the string
 */
function parseMathArgument(
    s: string,
    options: {
        noWrap?: boolean;
        format?: string;
        inlineShortcuts?: { [key: string]: InlineShortcutDefinition };
    }
): { match: string; rest: string } {
    let match = '';
    s = s.trim();
    let rest = s;
    let lFence = s.charAt(0);
    let rFence = { '(': ')', '{': '}', '[': ']' }[lFence];
    if (rFence) {
        // It's a fence
        let level = 1;
        let i = 1;
        while (i < s.length && level > 0) {
            if (s[i] === lFence) level++;
            if (s[i] === rFence) level--;
            i++;
        }
        if (level === 0) {
            // We've found the matching closing fence
            if (options.noWrap && lFence === '(') {
                match = parseMathExpression(s.substring(1, i - 1), options);
            } else {
                if (lFence === '{' && rFence === '}') {
                    lFence = '\\{';
                    rFence = '\\}';
                }
                match =
                    '\\left' +
                    lFence +
                    parseMathExpression(s.substring(1, i - 1), options) +
                    '\\right' +
                    rFence;
            }
            rest = s.substring(i);
        } else {
            // Unbalanced fence...
            match = s.substring(1, i);
            rest = '';
        }
    } else {
        let m = s.match(/^([a-zA-Z]+)/);
        if (m) {
            // It's a string of letter, maybe a shortcut
            let shortcut = getInlineShortcut(null, s, options.inlineShortcuts);
            if (shortcut) {
                shortcut = shortcut.replace('_{#?}', '');
                shortcut = shortcut.replace('^{#?}', '');
                return { match: shortcut, rest: s.substring(shortcut.length) };
            }
        }

        m = s.match(/^([a-zA-Z])/);
        if (m) {
            // It's a single letter
            return { match: m[1], rest: s.substring(1) };
        }

        m = s.match(/^(-)?\d+(\.\d*)?/);
        if (m) {
            // It's a number
            return { match: m[0], rest: s.substring(m[0].length) };
        }

        if (!/^\\(left|right)/.test(s)) {
            // It's a LaTeX command (but not a \left\right)
            m = s.match(/^(\\[a-zA-Z]+)/);
            if (m) {
                rest = s.substring(m[1].length);
                match = m[1];
            }
        }
    }

    return { match: match, rest: rest };
}

function paddedShortcut(s: string, options: { format?: string }): string {
    let result = getInlineShortcut(null, s, options);
    if (result) {
        result = result.replace('_{#?}', '');
        result = result.replace('^{#?}', '');
        result += ' ';
    } else {
        result = s;
    }
    return result;
}
